<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>WebWorker Tests</title>


<link href="./css/main.css" rel="stylesheet" type="text/css" />

<script type="text/javascript" src="./js/jquery.js"></script>
<script type="text/javascript" src="./js/main.js"></script>

</head>
<body>
<div class='wrap-fix'>
<div class="page-wrap">
   <div class="header">
   <div class='title'>
   <h1>Web Worker Experiments</h1>
   <h2>An investigation into how web workers operate.</h2>
   </div>
   <div class='h-menu'>
   <span><a href='#intro'>Introduction</a></span>&nbsp;|&nbsp;
   <span><a href='#start'>Getting Started</a></span>&nbsp;|&nbsp;
   <span><a href='#part-1'>Part I</a></span>&nbsp;|&nbsp;
   <span><a href='#part-2'>Part II</a></span>&nbsp;|&nbsp;
   <span><a href='#part-3'>Part III</a></span>
   </div>
   </div>
   <div class="body">
   <div class='section' id='intro' title='Introduction'>
       <p>A phrase I've been hearing used a lot lately, "Web Workers".&nbsp;&nbsp;What is a web worker?&nbsp;&nbsp;What can I do with one?&nbsp;&nbsp;Through this tutorial I will have you follow along with me while I go through some steps to understanding what a Web Worker is and how we can use these in actual situations.&nbsp;&nbsp;Prior to this I have no knowledge whatsoever as to what they are used for and what they are capable of, but hopefully by the end of this I will!</p>
   </div>
   <div class='section' id='start' title='Getting Started'>
       <p>First let's get our basic template for our page setup, you can download the template <a href='./step/start.rar' target="_blank">HERE</a>, or you can set up whatever basic index page is most comfortable to work in.</p>
    <p>What does <a href='https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers' target='_blank'>developer.mozilla.org</a> say about Web Workers? </p>
   <div class='quote'>
   Web Workers provide a simple means for web content to run scripts in background threads. The worker thread can perform tasks without interfering with the user interface. In addition, they can perform I/O using XMLHttpRequest (although the responseXML and channel attributes are always null). Once created, a worker can send messages to the JavaScript code that created it by posting messages to an event handler specified by that code (and vice versa.) This article provides a detailed introduction to using web workers.
   </div>
   <p>Ok, so this sounds really promising!  What I am getting out of this is that Web Workers can simulate multithreading and could also serve as a pseudo response server for more dynamic content.</p>
   <p>Also the thought of nesting certain calculation functions inside another script could allow more dynamic animations on a canvas element, or any other intensive calculation.
   A few points about scope, if we create a web worker thread it creates a new thread outside of the scope of the window.  If at any time we would need to refer to the 'window' that called the worker thread we would instead of using <b>window</b> use <b>self</b>.</p>
  <p>Other Key Points:
  <ul>
  <li>A dedicated worker is only accessible from the script that first spawned it, whereas shared workers can be accessed from multiple scripts.</li>
  <li>You can't directly manipulate the DOM from inside a worker, or use some default methods and properties of the window object.</li>
  <li><a href='https://developer.mozilla.org/en-US/docs/Web/API/Worker/Functions_and_classes_available_to_workers' target='_blank'>Functions and classes available to workers</a></li>
  <li>Workers can spawn new workers, those workers must be hosted within the same origin as the parent page.</li>
  </ul>  
  </p>
  <p>I would recommend reading the mozilla page, as most of this tutorial will be based off the information served there.</p>
  </div>
     
     <div class='section' id='part-1' title='Part I'>
     <h3>Web Worker detection and setting up our first thread.</h3>
       <p>Now that we have an idea of what one is, let's go ahead and jump right to the main.js file and start making some changes.</p>
    <pre title='main.js'><xmp>window.onload = function() {
    if (window.Worker) {
         document.body.innerHTML = "We Have Ignition";
    }else{
         document.body.innerHTML = "Lame sauce... no Web Workers...";
    }
}</xmp></pre>
    <p>If you have ignition, then you are good to go!  If not then, yeah something is wrong because pretty sure most modern browsers have these... geez guy/gal.</p>
    <p>From this point we need to actually do something with a web worker so the first step in that will be to go to our js folder and create a new script called "worker1.js" and then edit both the main script and the worker script accordingly.</p>
   
    <pre title='main.js'><xmp>window.onload = function() {
    if (window.Worker) {
         var newWorker = new Worker("./js/worker1.js");
        
              newWorker.postMessage([1,"Two"]);
              console.log('Message posted...');
            
            newWorker.onmessage = function(e) {
                  result = e.data;
                  console.log(result);
            }

    }else{
         document.body.innerHTML = "Lame sauce... no Web Workers...";
    }
}</xmp></pre>
    <pre title='worker1.js'><xmp>onmessage = function(e) {
  console.log('Message received from main script');
  var workerResult = 'Result: ' + (e.data[0] + e.data[1]);
  console.log('Posting message back to main script');
  postMessage(workerResult);
}</xmp></pre>
<p>What is happening here is first we are creating our instance of the worker on our main script.  Then we are using the built in method .postMessage which will be the main basis for communicating with out worker.  Then we have the worker listen for a message by defining the onmessage function, do whatever we want with the data and then pass it back!  If everything is set up right when you refresh the page nothing amazing happens, but when you look in the console you will see the desired output hopefully.  If you are having trouble or just feel like skipping this step you can download it <a href='./step/step1.rar'>HERE</a></p>
</div>
<div class='section' id='part-2' title='Part II'>
     <h3>Implementing and Creating Our First Project!</h3>
     <p>Now that we have this set up, what is something we could make?  Hmmmm, I know how about Pong.  We will get to learn how to use the Web Worker to do all the calculations and just have the main page update the canvas.  If we do things right we could perhaps have one worker for calculating what is happening and the other calculating the output to the canvas.  This may not be ideal or even the correct thing to do, but this is open research so I have no shame.</p>
     <p>Because we don't have another person and I don't feel like going over AI for this tutorial, lets make a game that we can play with ourselves (ha).  So to get things rolling let's make these changes to our index.html, main.js and main.css.

<pre title='index.html'><xmp><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Web Workers Step 2</title>
<link href="./css/main.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="./js/main.js"></script>
</head>
<body>
<canvas id='cvas'></canvas>
<div id='score'></div>
</body>
</html></xmp></pre>

<pre title='main.css'><xmp>@charset "utf-8";
/* Web Workers Tutorial */
html, body{
padding:0; margin:0;
min-height:100%;
height:100%;
}

#score{
    position:absolute;
    top:1em;
    left:1em;
    font-family:"Lucida Console", Monaco, monospace;
    font-size:18px;
    font-variant:small-caps;
    opacity:0.5;
}</xmp></pre>

<pre title='main.js'><xmp>window.onload = function() {
    cvas = document.getElementById('cvas'); //Lets make it Global ^_^
    var context = cvas.getContext('2d');
    var score = document.getElementById('score');
    score.innerHTML = "Score: 0";
    function resize(){
        cvas.setAttribute("width", window.innerWidth+'px');
        cvas.setAttribute("height", window.innerHeight+'px');
        drawBall();
        drawPlayer();
        return    
    }
    resize();
    window.onresize = resize;
    
    
    //Lets just Draw our ball for now and paddles for now.
      function drawBall(){      
      var centerX = cvas.width / 2;
      var centerY = cvas.height / 2;
      var radius = cvas.height / 40;
      context.beginPath();
      context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
      context.fillStyle = 'blue';
      context.fill();
      context.lineWidth = 1;
      context.strokeStyle = 'blue';
      context.stroke();
      }
      
      function drawPlayer(){      
      var centerX = cvas.width / 2;
      var centerY = cvas.height - 20;
      var width = cvas.width / 10;
      var height = 10;
      context.fillStyle = 'red';
      context.fillRect(centerX - (width*0.5) ,centerY,width,height);
      }
    
    
    if (window.Worker) {
         var newWorker = new Worker("./js/worker1.js");
        
              newWorker.postMessage([1,"Two"]);
              console.log('Message posted...');
            
            newWorker.onmessage = function(e) {
                  result = e.data;
                  console.log(result);
            }

    }else{
         document.body.innerHTML = "Lame sauce... no Web Workers...";
    }
}</xmp></pre>
<p>If you're all set up things should look like this.</p>
<iframe frameborder="0" width="100%" height="600px" src="https://pryme8.github.io/NeatFlax/webWork/step/step2/index.html"></iframe><BR/>
<p>Ok, so basically all we did was set up a resize listener, and some basic function to figure out how we are going to draw the objects</p>
<p>Now that we got some basic things set up its time to get to core structure of our program.  You can <a href='./step/step2.rar'>download</a> step 2 if you feel like skipping to this point or are having trouble.</p>
</div>
<div class='section' id='part-3' title='Part III'>
     <h3>The Long Haul... Core Changes</h3>
<p>So the first thing on the chopping block, is let's get a ASYNC loop set up with a throttle on it so we're not just calculating for no reason on the draws.  Then move the functions for drawing on the canvas onto the worker and see if it all still works.  I'm not sure if this can all happen on the worker, but I have a sneaking suspicion that it will work just fine as long as we make sure we set up the correct scopes.</p>
<p>That means we will be editing the worker1.js file.</p>  

<pre title='worker1.js'><xmp>newGame = null;
onmessage = function(e) {
  console.log('Message received from main script');
  var type = null;
  if(e.data.length){
      type = e.data[0];
  }
    switch(type){
    case "init" : newGame = new pong(e.data[1]);
    break;
    
        console.log('new Game');
    }
}

pong = function(cvas){
    this.score = 0;
    this.run = false;
    this._cvas = cvas;
};</xmp></pre>

<pre title='main.js'><xmp>if (window.Worker) {
         var newWorker = new Worker("./js/worker1.js");
        
              newWorker.postMessage(['init', cvas]);
              newWorker.onmessage = function(e) {
                  result = e.data;
                  console.log(result);
            }

    }else{
         document.body.innerHTML = "Lame sauce... no Web Workers...";
    }</xmp></pre>


<p>If we try to run this we get that the error: "DataCloneError: The object could not be cloned."  I believe this is because of instead of passing a reference of the object to the worker script it tried to make a clone of it, which is evidently not permitted with a canvas element (we could pass the imageData as a Buffer or Array though, but kinda overkill in this situation).  So our work arounds will be to try to pass the context of the canvas, or just have the main script do the canvas manipulations but have the worker thread do the calculations.  I'm not sure if this is even a correct use for a Web Worker but we will find out.</p>
<p>So I guess we should actually set up the structure for the game on the main thread, so on the main.js we add all the constants and containers for the game.  As of right now we will do a simple 30Hz interval loop to process what needs to be put onto the canvas.  Later we will make this loop more customizable and put in a way to set our FPS.  The concept that we will be testing is having the physics be calculated on the worker, and have it push the updated hits and other properties to the main thread to be processed.  Initially here we will set the main and worker thread to work at the same frequency, but later will prolly crank up the main thread to 60Hz and see how that affects performance.</p>
<pre title='main.js'><xmp>SCALE = 1;
CENTERX = 0;
CENTERY = 0;

Entity = function(id, pos){ //pos is an array(3) with [x,y,angle];
      this.id = id;
      this.pos = pos;
      this.velocity = [0,0,0]; // X,Y,ROTATION
      
}

Entity.prototype.update = function(state) {
      this.pos = state.pos;     
}

Entity.prototype.draw = function(ctx) {
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(this.pos[0]+CENTERX , this.pos[1]+CENTERY , 2, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.fill();
}

Ball = function(id, pos) {
      Entity.call(this, id, pos);
      this.body = {
          type:'circle',
            radius : SCALE,    
      }
}

Ball.prototype = new Entity();
Ball.prototype.constructor = Ball;

Ball.prototype.draw = function(ctx) {
      ctx.fillStyle = 'blue';
      ctx.beginPath();
      ctx.arc(this.pos[0]+CENTERX, this.pos[1]+CENTERY, SCALE, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.fill();      
      Entity.prototype.draw.call(this, ctx);
}

player = function(id, pos) {
     this.body = {
          type:'box',
            points : [
          [-(10 * SCALE)*0.5, -SCALE*0.5], //TL
          [(10 * SCALE)*0.5, -SCALE*0.5], //TR
           [-(10 * SCALE)*0.5, SCALE*0.5], //BL
          [(10 * SCALE)*0.5, SCALE*0.5] //BR
          ]    
      }
      Entity.call(this, id, pos);
}
    player.prototype = new Entity();
    player.prototype.constructor = player;
    
    player.prototype.draw = function(ctx) {
     ctx.fillStyle = 'red';
      ctx.fillRect((this.pos[0]+CENTERX)-((10 * SCALE)*0.5),
                   (window.innerHeight -20),
                   (10 * SCALE),
                   1 * SCALE);
    
     
}

pong = {
    ent_stack : [],
    gravity : [0,0.2],
    _init : null        
}


window.onload = function() {
    cvas = document.getElementById('cvas'); //Lets make it Global ^_^
    var ctx = cvas.getContext('2d');
    var score = document.getElementById('score');
    score.innerHTML = "Score: 0";
    pong.ent_stack.push(new Ball('b1', [0,0,0]));
    pong.ent_stack.push(new player('player1', [0, window.innerHeight - 20 ,0]));
    
    function resize(){
        cvas.setAttribute("width", window.innerWidth+'px');
        cvas.setAttribute("height", window.innerHeight+'px');
        SCALE = cvas.height / 40;
        CENTERX = cvas.width / 2;
        CENTERY = cvas.height / 2;
        reDraw();
        return    
    }
    
    function reDraw(){
        for(var i=0; i<pong.ent_stack.length; i++){
            pong.ent_stack[i].draw(ctx);
        }
    }
    
    resize();
    window.onresize = resize;
    
    
    if (window.Worker) {
        console.log("Worker Go!");
         var newWorker = new Worker("./js/worker1.js");
        
              newWorker.postMessage(['init']);
            
              /*newWorker.onmessage = function(e) {
                  var result = e.data;
                  if(result[0]=='update'){
                
                }
                
            }*/
            
            setInterval(function(){
              ctx.clearRect(0, 0, cvas.width, cvas.height);
              reDraw();   
            },1000/30);

    }else{
         document.body.innerHTML = "Lame sauce... no Web Workers...";
    }
}</xmp></pre>

<p>Now the break down on this is as follows.  One, we set up some global variables that will hold things that determine our size of our entities being drawn on the canvas.  We make them global because at any point the user may resize the document and we want everything to remain the same.  Right now we will disinclude the scale into the physics calculations, but later we will have to make sure we apply the scale to the physics as well so that the velocities and gravity etc stay proportionate.</p>
<p>Next we define our basic Entity Object, and its prototypes.  This will be the basic container for whatever other objects we want to render on the screen.  We give the Entity Object a draw prototype that should give us a center point.  If you want to use the center point you must make sure that if your not spawning whatever entity at the center of the canvas, you need to translate the context prior to the output otherwise the dot will not be on the center of the new entity (not important we only using it on the ball which spawns in the center).  </p>
<p>Then we define different Constructors for the Entity Object so that we can call different shapes.  This is a very basic prototype/constructor layout and should be fairly straightforward to understand.  After we have our Constructors ready we need to define a global container for everything.  In this global container "pong", we can define some constants as well.  Once the DOM has loaded, we create the new entities and push them to a stack on our global container.  Modify our all so important resize function, and then create a new function to call the draw method on all active entities.  You could at this point put and enabled disabled flag on the Entities to toggle them on or off, but we'll save that for later.</p>
<p>If in your interval loop, we stick the argument pong.ent_stack[0].pos[1]+= 0.25; You will see the ball move, which means we are on the right track.</p>
</div>


</div>
</div>
   <div class="footer"></div>
</div>
</body>
</html>
